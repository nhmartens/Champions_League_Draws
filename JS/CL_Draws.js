'use strict';

let computedProbabilities = {};
let fullCompatibilityMatrix;

let seasonId;
let seasonLog = {};

function initialize(attr1, attr2) {
	if (attr2 == null && !Array.isArray(attr1[0][0])) {
		fullCompatibilityMatrix = attr1;
	} else {
		let attributes;
		if (attr2 != null) {
			attributes = [attr1, attr2];
		} else {
			attributes = attr1;
		}
		fullCompatibilityMatrix = [];
		// use attributes to build compatibility matrix
		for (let i = 0; i < attributes[0].length; i++) {
			let row = [];
			for (let j = 0; j < attributes[0].length; j++) {
				let matchable = true;
				for (let k = 0; k < attributes[0][i].length; k++) {
					if (attributes[0][i][k] == attributes[1][j][k] && attributes[0][i][k] != null
							&& attributes[1][j][k] != null && attributes[0][i][k] !== '' && attributes[1][j][k] !== '') {
						matchable = false;
					}
				}
				if (matchable) {
					row.push(true);
				} else {
					row.push(false);
				}
			}
			fullCompatibilityMatrix.push(row);
		}
	}
	seasonId = idToString(generateSortedId(fullCompatibilityMatrix)[0]);
	if (seasonLog[seasonId] == undefined) {
		seasonLog[seasonId] = new Set();
	}
}

function sortMatrix(matrix, rowOrder, columnOrder, inverse) {
	let result = [];
	for (let i = 0; i < rowOrder.length; i++) {
		result[i] = [];
	}
	for (let i = 0; i < rowOrder.length; i++) {
		for (let j = 0; j < rowOrder.length; j++) {
			if (!inverse) {
				result[i][j] = matrix[rowOrder[i]][columnOrder[j]];
			} else {
				result[rowOrder[i]][columnOrder[j]] = matrix[i][j];
			}
		}
	}
	return result;
}

// maps each row/column of the (boolean) compatibility matrix to
// an int in {0,...,(2^n)-1} (n := number of undrawn winners)
function generateUnsortedId(matrix, order, rowMode) {
	let id = [];
	for (let i = 0; i < matrix.length; i++) {
		let temp = 0;
		for (let j = 0; j < matrix.length; j++) {
			temp <<= 1;
			let entry;
			if (rowMode) {
				entry = matrix[i][j];
			} else {
				entry = matrix[j][i];
			}
			if (entry) {
				temp |= 1;
			}
		}
		id.push([temp, order[i]]);
	}
	return id;
}



// generates an identifier for the undrawn teams by
// alternatingly sorting columns and rows of compatibility matrix until ID
// generated by generateUnsortedId() does not change anymore;
// result includes two order arrays characterizing the permutation of 
// the original matrix to undo or redo the sorting
function generateSortedId(compatibilityMatrix) {
	let rowOrder = [];
	let columnOrder = [];
	for (let i = 0; i < compatibilityMatrix.length; i++) {
		rowOrder.push(i);
		columnOrder.push(i);
	}

	let matrix2 = compatibilityMatrix;
	let row = true;
	let sorted = [false, false];
	let id;
	// alternatingly sort rows and columns
	while (true) {
		let order;
		if (row) {
			order = rowOrder;
		} else {
			order = columnOrder;
		}
		let subId = generateUnsortedId(matrix2, order, row);
		sorted[row ? 0 : 1] = true;
		let maximum = -1;
		for (let i = 0; i < subId.length; i++) {
			if (subId[i][0] < maximum) {
				sorted[row ? 0 : 1] = false;
				break;
			} else {
				maximum = subId[i][0];
			}
		}
		if (!sorted[row ? 0 : 1]) {
			subId.sort(function(a,b) {
				return a[0] - b[0];
			});
			for (let i = 0; i < subId.length; i++) {
				order[i] = subId[i][1];
			}
		}
		if (row) {
			id = subId;
		}
		if (sorted[0] && sorted[1]) {
			break;
		}
		matrix2 = sortMatrix(compatibilityMatrix, rowOrder, columnOrder);
		row = !row;
	}
	let key = [];
	for (let i = 0; i < id.length; i++) {
		key[i] = id[i][0];
	}

	return [key, rowOrder, columnOrder];
}


function idToString(id) {
	let s = '';
	for (let i = 0; i < id.length; i++) {
		if (id[i] < 16) {
			s += '000' + (id[i]).toString(16);
		} else if (id[i] < 256) {
			s += '00' + (id[i]).toString(16);
		} else if (id[i] < 4096) {
			s += '0' + (id[i]).toString(16);
		} else {
			s += (id[i]).toString(16);
		}
	}
	return s;
}

// returns cached probabilities, null if dead end or undefined if not cached yet
function loadProbabilities(id) {
	let s = idToString(id[0]);
	seasonLog[seasonId].add(s);
	let temp = computedProbabilities[s];
	if (temp == null) {
		return temp;
	}
	let probabilities = sortMatrix(temp, id[1], id[2], true);
	return probabilities;
}

// caches probabilities
function saveProbabilities(id, probabilities) {
	let s = idToString(id[0]);
	computedProbabilities[s] = probabilities;
	if (probabilities == null) {
		computedProbabilities[s] = null;
	} else {
		let temp = sortMatrix(probabilities, id[1], id[2]);
		computedProbabilities[s] = temp;
	}
}

let count = 0
function computeProbabilities(compatibilityMatrix, unmatchedRunnerUp) {
	count += 1
	let id;
	if (unmatchedRunnerUp == undefined) {
		// use cached probabilities if existing
		id = generateSortedId(compatibilityMatrix);
		let cachedProbabilities = loadProbabilities(id);
		if (cachedProbabilities !== undefined) {
			return cachedProbabilities;
		}
	}

	let probabilities = [];
	let options = 0;
	let size = compatibilityMatrix.length;

	for (let i = 0; i < size; i++) {
		probabilities[i] = [];
		for (let j = 0; j < size; j++) {
			probabilities[i][j] = 0;
		}
	}

	// if the same number of winners and runners-up has been drawn
	if (unmatchedRunnerUp == undefined) {
		for (let i = 0; i < size; i++) {
			options++;
			// temporarily draw runner-up i and compute the resulting probabilities
			let conditionalProbabilities = computeProbabilities(compatibilityMatrix, i);
			if (conditionalProbabilities === null) {
				options--;
			} else {
				for (let j = 0; j < size; j++) {
					for (let k = 0; k < size; k++) {
						probabilities[j][k] += conditionalProbabilities[j][k];
					}
				}
			}
		}
		// return null if the current draw is a dead end
		if (options == 0 && size > 0) {
			probabilities = null;
		}

	// if an opponent for team 'unmatchedRunnerUp' is to be drawn next
	} else {
		for (let i = 0; i < size; i++) {
			if (compatibilityMatrix[i][unmatchedRunnerUp]) {
				options++;
				// temporarily match unmatchedRunnerUp with winner i and compute the resulting probabilities
				let subMatrix = [];
				for (let j = 0; j < size; j++) {
					if (j != i) {
						let row = [];
						for (let k = 0; k < size; k++) {
							if (k != unmatchedRunnerUp) {
								row.push(compatibilityMatrix[j][k]);
							}
						}
						subMatrix.push(row);
					}
				}
				let conditionalProbabilities = computeProbabilities(subMatrix);
				if (conditionalProbabilities === null) {
					options--;
				} else {
					for (let j = 0; j < size; j++) {
						for (let k = 0; k < size; k++) {
							if (j < i) {
								if (k < unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j][k];
								}
								if (k > unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j][k - 1];
								}
							} else if (j > i) {
								if (k < unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j - 1][k];
								}
								if (k > unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j - 1][k - 1];
								}
							}
						}
					}
					probabilities[i][unmatchedRunnerUp] += 1;
				}
			}
		}
		// return null if the current draw is a dead end
		if (options == 0) {
			probabilities = null;
		}
	}

	if (options != 0) {
		for (let i = 0; i < size; i++) {
			for (let j = 0; j < size; j++) {
				probabilities[i][j] /= options;
			}
		}
	}

	if (unmatchedRunnerUp == undefined) {
		saveProbabilities(id, probabilities);
	}
	return probabilities;
}


function getProbabilities(drawnW, drawnR, unmatchedRunnerUp) {
	if (drawnW == null) {
		return computeProbabilities(fullCompatibilityMatrix);
	}
	let compatibilityMatrix = [];
	for (let i = 0; i < fullCompatibilityMatrix.length; i++) {
		if (!drawnW[i]) {
			let row = [];
			for (let j = 0; j < fullCompatibilityMatrix.length; j++) {
				if (!drawnR[j] || j == unmatchedRunnerUp) {
					if (fullCompatibilityMatrix[i][j]) {
						row.push(true);
					} else {
						row.push(false);
					}
				}
			}
			compatibilityMatrix.push(row);
		}
	}
	for (let i = unmatchedRunnerUp - 1; i >= 0; i--) {
		if (drawnR[i]) {
			unmatchedRunnerUp--;
		}
	}
	return computeProbabilities(compatibilityMatrix, unmatchedRunnerUp);
}


function exportProbabilities(limit) {
	if (limit == undefined) {
		limit = 0;
	}
	let croppedProbabilities = {};
	for (let id of seasonLog[seasonId]) {
		// only consider probabilities for cases where >= 'limit' teams are in the winners pot
		if (id.length >= limit * 4) {
			croppedProbabilities[id] = computedProbabilities[id];
		}
	}
	return croppedProbabilities;
}


function importProbabilities(probabilities) {
	for (let id in probabilities) {
		computedProbabilities[id] = probabilities[id];
	}
}


function clearCache() {
	computedProbabilities = {};
}


function getId() {
	return [seasonId, computedProbabilities[seasonId] !== undefined];
}

console.profile("label");
var winners = [["A","DE"], ["B","EN"], ["C","ES"], ["D","ES"], ["E","ES"], ["F","DE"], ["G","EN"], ["H","ES"]];
var runnersUp = [["A","DEN"], ["B","NE"], ["C","IT"], ["D","IT"], ["E","IT"], ["F","FR"], ["G","DE"], ["H","PR"]];
initialize(winners, runnersUp);
console.time('Execution time');
let a = getProbabilities();
console.timeEnd('Execution time');

const numberOfElements = Object.keys(computedProbabilities).length;
console.log(numberOfElements);
console.log(a);
console.profileEnd();
//console.log(computeProbabilities([[false, true, true], [true, false, true], [true, true, false]]));
